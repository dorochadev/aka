package launcher

import (
	"fmt"
	"regexp"
	"runtime"
	"strings"
)

var sshPattern = regexp.MustCompile(`^[a-zA-Z0-9_.-]+@[\w\.\-]+$`)

func DetectLauncherType(target string) LauncherType {
	if strings.HasPrefix(target, "http://") || strings.HasPrefix(target, "https://") {
		return TypeURL
	}

	if sshPattern.MatchString(target) {
		return TypeSSH
	}

	if strings.Contains(target, " ") || strings.ContainsAny(target, "|><&;") {
		return TypeCommand
	}

	return TypeApplication
}

func GenerateScript(target string, metadata *LauncherMetadata) string {
	if metadata.Type == TypeStack {
		return generateStackScript(metadata)
	}

	switch metadata.Type {
	case TypeURL:
		return generateURLScript(target)
	case TypeSSH:
		return generateSSHScript(target, metadata.SSHConfig)
	case TypeCommand:
		return generateCommandScript(target, metadata.Env)
	default:
		return generateAppScript(target, metadata.Env)
	}
}

func generateStackScript(metadata *LauncherMetadata) string {
	var commands []string

	// Handle Env vars globally for the script if any
	envVars := ""
	if len(metadata.Env) > 0 {
		for key, value := range metadata.Env {
			envVars += fmt.Sprintf("export %s=\"%s\"\n", key, value)
		}
	}

	for _, t := range metadata.Targets {
		type_ := DetectLauncherType(t)
		var cmd string
		switch type_ {
		case TypeURL:
			cmd = getURLCommand(t)
		case TypeSSH:
			// Stack SSH doesn't support complex config yet, just basic connection
			cmd = fmt.Sprintf("ssh %s", t)
		case TypeCommand:
			cmd = t
		default: // App
			cmd = getAppCommand(t)
		}
		commands = append(commands, cmd)
	}

	return fmt.Sprintf(`#!/bin/sh
# Generated by aka - Stack launcher
%s
%s
`, envVars, strings.Join(commands, "\n"))
}

func getURLCommand(url string) string {
	switch runtime.GOOS {
	case "darwin":
		return fmt.Sprintf(`open "%s"`, url)
	case "linux":
		return fmt.Sprintf(`xdg-open "%s"`, url)
	default:
		return fmt.Sprintf(`echo "Unsupported platform: %s"`, runtime.GOOS)
	}
}

func getAppCommand(appName string) string {
	switch runtime.GOOS {
	case "darwin":
		return fmt.Sprintf(`open -a "%s"`, appName)
	case "linux":
		return fmt.Sprintf(`xdg-open "%s" || echo "Error: %s"`, appName, appName)
	default:
		return fmt.Sprintf(`echo "Unsupported: %s"`, appName)
	}
}

func generateURLScript(url string) string {
	cmd := getURLCommand(url)

	return fmt.Sprintf(`#!/bin/sh
# Generated by aka - URL launcher
%s
`, cmd)
}

func generateSSHScript(target string, config *SSHConfig) string {
	var flags []string

	if config != nil {
		if config.KeyFile != "" {
			flags = append(flags, fmt.Sprintf(`-i "%s"`, config.KeyFile))
		}
		if config.Port != 0 && config.Port != 22 {
			flags = append(flags, fmt.Sprintf("-p %d", config.Port))
		}
	}

	flagStr := ""
	if len(flags) > 0 {
		flagStr = " " + strings.Join(flags, " ")
	}

	var cmd string
	if config != nil && config.Password != "" {
		cmd = fmt.Sprintf(`sshpass -p '%s' ssh%s %s`, config.Password, flagStr, target)
	} else {
		cmd = fmt.Sprintf(`ssh%s %s`, flagStr, target)
	}

	return fmt.Sprintf(`#!/bin/sh
# Generated by aka - SSH launcher
%s
`, cmd)
}

func generateCommandScript(command string, env map[string]string) string {
	envVars := ""
	if len(env) > 0 {
		for key, value := range env {
			envVars += fmt.Sprintf("export %s=\"%s\"\n", key, value)
		}
	}

	return fmt.Sprintf(`#!/bin/sh
# Generated by aka - Command launcher
%s%s
`, envVars, command)
}

func generateAppScript(appName string, env map[string]string) string {
	envVars := ""
	if len(env) > 0 {
		for key, value := range env {
			envVars += fmt.Sprintf("export %s=\"%s\"\n", key, value)
		}
	}

	cmd := getAppCommand(appName)

	return fmt.Sprintf(`#!/bin/sh
# Generated by aka - launcher for %s
%s%s
`, appName, envVars, cmd)
}
